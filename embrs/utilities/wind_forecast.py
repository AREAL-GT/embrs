import subprocess
import os
import json
import numpy as np

cli_path = "/Users/rui/Documents/Research/Code/wind/build/src/cli/WindNinja_cli"

# Path to store temporary files generated by WindNinja
temp_file_path = "/Users/rui/Documents/Research/Code/wind/build/src/cli/temp"

def gen_forecast(elevation_path, vegetation_path, forecast_seed_path, forecast_seed_type, mesh_resolution=250):
    if forecast_seed_type == "domainAverageInitialization":
        # Run WindNinja with domain average initialization
        time_step = run_domain_avg_windninja(elevation_path, vegetation_path, forecast_seed_path, mesh_resolution)

    elif forecast_seed_type == "pointInitialization":
        # Run WindNinja with point initialization
        run_point_windninja()

    elif forecast_seed_type == "wxModelInitialization":
        # Run WindNinja with weather model initialization
        run_wxmodel_windninja()

    # Save metadata
    metadata = {
        "mesh_resolution": mesh_resolution,
        "time_step": time_step
    }
    with open(os.path.join(temp_file_path, "wind_metadata.json"), 'w') as file:
        json.dump(metadata, file)

def run_domain_avg_windninja(elevation_path, vegetation_path, seed_path, mesh_resolution=250):
    # Parse the forecast seed
    # Load wind forecast and initialize wind vector
    with open(seed_path, 'r') as file:
        seed_data = json.load(file)

    time_step = seed_data['time_step_min']
    speed_list = []
    direction_list = []
    for entry in seed_data['data']:
        speed_list.append(entry['speed_m_s'])

        # Convert direction to WindNinja convention
        direction = (entry['direction'] + 180) % 360
        direction_list.append(direction)

    # TODO: Implement wind height in wind forecast seed generation
    wind_height = seed_data['wind_height']
    wind_height_units = seed_data['wind_height_units']

    for i, (speed, direction) in enumerate(zip(speed_list, direction_list)):
        os.makedirs(os.path.join(temp_file_path, f"{i}"), exist_ok=True)
        output_path = os.path.join(temp_file_path, f"{i}")

        # Build the WindNinja CLI command
        command = [
            cli_path,
            "--initialization_method", "domainAverageInitialization",
            "--elevation_file", elevation_path,
            "--output_path", output_path, 
            "--vegetation", vegetation_path, # TODO: test with actual vegetation file
            "--mesh_resolution", str(mesh_resolution),
            "--units_mesh_resolution", "m",
            "--num_threads", "4",
            "--output_wind_height", "6.1",
            "--units_output_wind_height", "m",
            "--input_speed", str(speed),
            "--input_speed_units", "mps",
            "--input_direction", str(direction),
            "--input_wind_height", str(wind_height),
            "--units_input_wind_height", wind_height_units,
            "--write_ascii_output", "true"
        ]

        try:
            # Run the WindNinja CLI command
            subprocess.run(command, check=True)

            rename_windninja_outputs(output_path, i)

        except subprocess.CalledProcessError as e:
            print(f"Error running WindNinja CLI: {e}")
    
    # Create Forecast file
    create_forecast_file(save_path, len(speed_list))

    return time_step

def run_point_windninja():
    raise NotImplementedError("Point initialization not yet implemented")


def run_wxmodel_windninja():
    raise NotImplementedError("Weather model initialization not yet implemented")

def rename_windninja_outputs(output_path, time_step_index):
    """
    Rename WindNinja output files in the specified directory to a standard format.

    :param output_path: Directory where WindNinja outputs are stored.
    :type output_path: str
    :param time_step_index: Time step index to include in the file names.
    :type time_step_index: int
    """
    for file_name in os.listdir(output_path):
        old_path = os.path.join(output_path, file_name)
        if os.path.isfile(old_path):
            # Create a standardized file name
            extension = os.path.splitext(file_name)[1]
            if "_vel" in file_name:
                new_file_name = f"wind_speed_{time_step_index}{extension}"
            elif "_ang" in file_name:
                new_file_name = f"wind_direction_{time_step_index}{extension}"
            elif "_cld" in file_name:
                new_file_name = f"cloud_cover_{time_step_index}{extension}"

            new_path = os.path.join(output_path, new_file_name)
            os.rename(old_path, new_path)

def create_forecast_file(save_path, num_files):
    for i in range(num_files):
        output_path = os.path.join(temp_file_path, f"{i}")

        speed_file = os.path.join(output_path, f"wind_speed_{i}.asc")
        direction_file = os.path.join(output_path, f"wind_direction_{i}.asc")

        if os.path.exists(speed_file) and os.path.exists(direction_file):            
            with open(speed_file, 'r') as file:
                speed_data = np.loadtxt(file, skiprows=6)

                if i == 0:
                    wind_data = np.zeros((num_files, *speed_data.shape, 2))

                wind_data[i, :, :, 0] = speed_data
            
            with open(direction_file, 'r') as file:
                direction_data = np.loadtxt(file, skiprows=6)
                direction_data = convert_to_cartesian(direction_data)
                wind_data[i, :, :, 1] = direction_data
    
    # Delete the temporary directories after data is gathered
    print("Removing temporary files...")
    for i in range(num_files):
        output_path = os.path.join(temp_file_path, f"{i}")
        if os.path.exists(output_path):
            for file_name in os.listdir(output_path):
                file_path = os.path.join(output_path, file_name)
                if os.path.isfile(file_path):
                    os.remove(file_path)
            os.rmdir(output_path)

    # Save wind data to .npy file
    np.save(os.path.join(save_path, "wind_forecast.npy"), wind_data)
    print("Wind forecast saved to: ", os.path.join(save_path, "wind_forecast.npy"))

def convert_to_cartesian(direction_data):
    return (180 + direction_data) % 360

# Test Code
elevation_path = "/Users/rui/Documents/Research/Code/embrs_raw_data/west_of_denver/LF2020_Elev_220_CONUS/LC20_Elev_220.tif"
vegetation_path = "grass"
forecast_seed_path = "/Users/rui/Documents/Research/Code/embrs/sample_wind_forecasts/burnout_wind_forecast.json"
forecast_seed_type = "domainAverageInitialization"

save_path = "/Users/rui/Documents/Research/Code/wind_forecast_test"

gen_forecast(save_path, elevation_path, vegetation_path, forecast_seed_path, forecast_seed_type)