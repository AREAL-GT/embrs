"""Wind forecast processing using WindNinja.

This module provides functions for generating and processing wind forecasts using WindNinja. 
It supports different initialization methods, handles WindNinja CLI execution, and structures 
wind data into NumPy arrays for use in wildfire simulations.

Features:
    - **Wind Forecast Generation**:
        - `gen_forecast()`: Runs WindNinja with domain-average, point-based, or weather model initialization.
        - `run_domain_avg_windninja()`: Executes WindNinja using domain-average wind initialization.
        - `run_point_windninja()`: Placeholder for point-based wind initialization.

    - **Wind Data Processing**:
        - `rename_windninja_outputs()`: Renames WindNinja-generated files to a standardized format.
        - `create_forecast_array()`: Loads WindNinja outputs into a structured NumPy array.
        - `convert_to_cartesian()`: Converts wind direction data from meteorological to Cartesian convention.

Dependencies:
    - **External Software**: WindNinja CLI must be installed and accessible at `cli_path`.
    - **Python Libraries**: Requires `subprocess`, `os`, `json`, `numpy`, and `typing`.

Paths:
    - `cli_path`: Path to the WindNinja CLI executable. **(TODO: Make user-configurable)**
    - `temp_file_path`: Path for storing temporary WindNinja outputs. **(TODO: Set dynamically based on `cli_path`)**

Usage:
    To generate a wind forecast using a domain-average wind:
    ```python
    forecast, time_step = gen_forecast(
        elevation_path="path/to/elevation.asc",
        vegetation_path="path/to/vegetation.asc",
        forecast_seed_path="path/to/wind_seed.json",
        forecast_seed_type="Domain Average Wind"
    )
    ```
"""

import subprocess
import os
import numpy as np
from typing import Tuple
from multiprocessing import cpu_count, Pool
from tqdm import tqdm
from embrs.utilities.data_classes import MapParams, WindNinjaTask
from embrs.utilities.weather import WeatherStream
from datetime import timedelta, datetime
import pytz

# Path to the WindNinja CLI executable # TODO: need a way to populate this for other users
cli_path = "/Users/rui/Documents/Research/Code/wind/build/src/cli/WindNinja_cli"

# Path to store temporary files generated by WindNinja # TODO: populate this based on location of CLI executable
temp_file_path = "/Users/rui/Documents/Research/Code/wind/build/src/cli/temp"


def run_windninja_single(task: WindNinjaTask):
    """Runs WindNinja for a single time step in parallel."""
    output_path = os.path.join(temp_file_path, f"{task.index}")
    os.makedirs(output_path, exist_ok=True)

    curr_datetime = task.start_datetime + timedelta(minutes=task.index * task.time_step)

    wind_dir = (task.entry.wind_dir_deg + task.north_angle) % 360

    command = [
        cli_path,
        "--initialization_method", "domainAverageInitialization",
        "--elevation_file", task.elevation_path,
        "--output_path", output_path,
        "--mesh_resolution", str(task.mesh_resolution),
        "--units_mesh_resolution", "m",
        "--time_zone", task.timezone,
        "--uni_air_temp", str(task.entry.temp),
        "--air_temp_units", task.temperature_units,
        "--uni_cloud_cover", str(task.entry.cloud_cover),
        "--cloud_cover_units", "percent",
        "--diurnal_winds", "false",
        "--year", str(curr_datetime.year),
        "--month", str(curr_datetime.month),
        "--day", str(curr_datetime.day),
        "--hour", str(curr_datetime.hour),
        "--minute", str(curr_datetime.minute),
        "--num_threads", "4",
        "--output_wind_height", "6.1",
        "--units_output_wind_height", "m",
        "--input_speed", str(task.entry.wind_speed),
        "--input_speed_units", task.input_speed_units,
        "--input_direction", str(wind_dir),
        "--input_wind_height", str(task.wind_height),
        "--units_input_wind_height", task.wind_height_units,
        "--write_ascii_output", "true",
        "--write_goog_output", "true"
    ]

    try:
        log_file = os.path.join(output_path, "windninja_log.txt")

        with open(log_file, "w") as file:
            subprocess.run(command, check=True, stdout=file, stderr=file) # TODO: is the HTTP 500 error ok?
        
        rename_windninja_outputs(output_path, task.index)

    except subprocess.CalledProcessError as e:
        print(f"Error running WindNinja CLI at step {task.index}: {e}")

def run_windninja(weather: WeatherStream, map: MapParams) -> Tuple[np.ndarray, float]:
    """Runs WindNinja with domain-average initialization in parallel."""
    
    # Extract data from forecast seed
    time_step = weather.time_step
    wind_height = weather.input_wind_ht
    wind_height_units = weather.input_wind_ht_units
    input_speed_units = weather.input_wind_vel_units
    temperature_units = weather.input_temp_units
    start_datetime = weather.params.start_datetime
    mesh_resolution = weather.params.mesh_resolution
    timezone = map.geo_info.timezone
    north_angle = map.geo_info.north_angle_deg

    if not type(start_datetime) == datetime:
        # Convert to naive datetime
        dt_local = datetime.fromisoformat(start_datetime)

        # Localize the datetime with the correct timezone
        tz = pytz.timezone(timezone)
        start_datetime = tz.localize(dt_local)

    # Clear temp folder
    if os.path.exists(temp_file_path):
        for file_name in os.listdir(temp_file_path):
            file_path = os.path.join(temp_file_path, file_name)
            if os.path.isfile(file_path):
                os.remove(file_path)
            elif os.path.isdir(file_path):
                for sub_file_name in os.listdir(file_path):
                    sub_file_path = os.path.join(file_path, sub_file_name)
                    if os.path.isfile(sub_file_path):
                        os.remove(sub_file_path)
                os.rmdir(file_path)

    # Prepare arguments for parallel execution
    tasks = [
        WindNinjaTask(
            index=i,
            time_step=time_step,
            entry=entry,
            elevation_path=map.cropped_lcp_path,
            timezone=timezone,
            north_angle=north_angle,
            mesh_resolution=mesh_resolution,
            temp_file_path=temp_file_path,
            cli_path=cli_path,
            start_datetime=start_datetime,
            wind_height=wind_height,
            wind_height_units=wind_height_units,
            input_speed_units=input_speed_units,
            temperature_units=temperature_units
        )
        for i, entry in enumerate(weather.stream)
    ]
    # Use multiprocessing Pool to parallelize
    num_tasks = len(tasks)
    num_workers = min(cpu_count(), num_tasks)  # Limit workers to available CPU cores

    pool = Pool(processes=num_workers)

    for _ in tqdm(pool.imap_unordered(run_windninja_single, tasks), total = num_tasks, desc="Generating wind with WindNinja: "):
        pass
    
    # Merge data into a forecast
    forecast = create_forecast_array(num_tasks)

    return forecast

def run_point_windninja():
    raise NotImplementedError("Point initialization not yet implemented")

def rename_windninja_outputs(output_path: str, time_step_index: int):
    """Renames WindNinja output files in a specified directory to a standardized format.

    This function processes WindNinja-generated output files, extracting wind speed, 
    wind direction, and cloud cover data. It renames the files using a structured 
    naming convention based on the provided time step index.

    Args:
        output_path (str): The directory where WindNinja outputs are stored.
        time_step_index (int): The index of the time step to include in the file names.

    Behavior:
        - Identifies files containing `_vel` (wind speed), `_ang` (wind direction), 
          and `_cld` (cloud cover).
        - Renames them to `wind_speed_<time_step>.asc`, `wind_direction_<time_step>.asc`, etc.
        - Ensures all files remain in the same directory.

    Notes:
        - Assumes WindNinja outputs are stored in ASCII format (`.asc`).
        - Cloud cover renaming is included but may not be relevant for all WindNinja runs.
    """
    for file_name in os.listdir(output_path):
        old_path = os.path.join(output_path, file_name)
        if os.path.isfile(old_path):
            # Create a standardized file name
            extension = os.path.splitext(file_name)[1]
            if "_vel" in file_name:
                new_file_name = f"wind_speed_{time_step_index}{extension}"
            elif "_ang" in file_name:
                new_file_name = f"wind_direction_{time_step_index}{extension}"
            elif "_cld" in file_name:
                new_file_name = f"cloud_cover_{time_step_index}{extension}"
            elif extension == ".kmz" or extension == ".kml":
                new_file_name = f"google_earth_{time_step_index}{extension}"
            else:
                continue

            new_path = os.path.join(output_path, new_file_name)
            os.rename(old_path, new_path)

def create_forecast_array(num_files: int) -> np.ndarray:
    """Loads WindNinja wind forecast outputs into a structured NumPy array.


    This function reads ASCII files produced by WindNinja, extracts wind speed 
    and direction data, and compiles them into a multi-dimensional NumPy array 
    for use in fire simulations.

    Args:
        num_files (int): The number of time steps (i.e., number of WindNinja-generated files).

    Returns:
        np.ndarray: A structured array with shape `(num_files, height, width, 2)`, 
                    where:
                    - `height` and `width` are the dimensions of the wind raster.
                    - The last axis stores wind components:
                        - `[:,:,0]` = Wind speed (m/s).
                        - `[:,:,1]` = Wind direction (converted to Cartesian).

    Behavior:
        - Iterates through each time step’s wind speed and direction files.
        - Loads wind speed (`wind_speed_<i>.asc`) and direction (`wind_direction_<i>.asc`).
        - Converts wind direction data using `convert_to_cartesian()`.
        - Constructs a forecast array with separate wind speed and direction layers.
        - Cleans up temporary WindNinja output directories after processing.

    Notes:
        - Expects WindNinja outputs to follow the standardized naming convention 
          produced by `rename_windninja_outputs()`.
        - Assumes WindNinja output files contain ASCII grid data with a 6-line header.
        - Uses `np.loadtxt()` to efficiently load numerical wind data.
    """

    for i in range(num_files):
        output_path = os.path.join(temp_file_path, f"{i}")

        speed_file = os.path.join(output_path, f"wind_speed_{i}.asc")
        direction_file = os.path.join(output_path, f"wind_direction_{i}.asc")

        if os.path.exists(speed_file) and os.path.exists(direction_file):            
            with open(speed_file, 'r') as file:
                speed_data = np.loadtxt(file, skiprows=6)

                if i == 0:
                    forecast = np.zeros((num_files, *speed_data.shape, 2))

                forecast[i, :, :, 0] = speed_data
            
            with open(direction_file, 'r') as file:
                direction_data = np.loadtxt(file, skiprows=6)
                direction_data = convert_to_cartesian(direction_data)
                forecast[i, :, :, 1] = direction_data

    return forecast

def convert_to_cartesian(direction_data: np.ndarray) -> np.ndarray:
    """Converts wind direction data to a Cartesian-compatible format.

    Wind direction in WindNinja outputs is typically measured in meteorological degrees 
    (0° = North-South, 90° = East-West, 180° = South-North, 270° = West-East). This function adjusts the values 
    to align with a Cartesian coordinate system.

    Args:
        direction_data (np.ndarray): A NumPy array containing wind direction values in degrees.

    Returns:
        np.ndarray: The transformed wind direction data, where:

            direction_cartesian = (180 + direction_data) % 360

    Notes:
        - This transformation ensures compatibility with fire spread models that 
          use Cartesian angle conventions.
        - Assumes wind direction values are given in degrees (0-360).
    """
    return (180 + direction_data) % 360