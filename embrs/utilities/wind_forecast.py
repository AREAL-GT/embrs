"""Wind forecast processing using WindNinja.

This module provides functions for generating and processing wind forecasts using WindNinja. 
It supports different initialization methods, handles WindNinja CLI execution, and structures 
wind data into NumPy arrays for use in wildfire simulations.

Features:
    - **Wind Forecast Generation**:
        - `gen_forecast()`: Runs WindNinja with domain-average, point-based, or weather model initialization.
        - `run_domain_avg_windninja()`: Executes WindNinja using domain-average wind initialization.
        - `run_point_windninja()`: Placeholder for point-based wind initialization.
        - `run_wxmodel_windninja()`: Placeholder for weather model-based wind initialization.

    - **Wind Data Processing**:
        - `rename_windninja_outputs()`: Renames WindNinja-generated files to a standardized format.
        - `create_forecast_array()`: Loads WindNinja outputs into a structured NumPy array.
        - `convert_to_cartesian()`: Converts wind direction data from meteorological to Cartesian convention.

Dependencies:
    - **External Software**: WindNinja CLI must be installed and accessible at `cli_path`.
    - **Python Libraries**: Requires `subprocess`, `os`, `json`, `numpy`, and `typing`.

Paths:
    - `cli_path`: Path to the WindNinja CLI executable. **(TODO: Make user-configurable)**
    - `temp_file_path`: Path for storing temporary WindNinja outputs. **(TODO: Set dynamically based on `cli_path`)**

Usage:
    To generate a wind forecast using a domain-average wind:
    ```python
    forecast, time_step = gen_forecast(
        elevation_path="path/to/elevation.asc",
        vegetation_path="path/to/vegetation.asc",
        forecast_seed_path="path/to/wind_seed.json",
        forecast_seed_type="Domain Average Wind"
    )
    ```
"""

import subprocess
import os
import json
import numpy as np
from typing import Tuple

from datetime import timedelta

# Path to the WindNinja CLI executable # TODO: need a way to populate this for other users
cli_path = "/Users/rui/Documents/Research/Code/wind/build/src/cli/WindNinja_cli"

# Path to store temporary files generated by WindNinja # TODO: populate this based on location of CLI executable
temp_file_path = "/Users/rui/Documents/Research/Code/wind/build/src/cli/temp"

def gen_forecast(elevation_path: str, vegetation_path: str, forecast_seed,
                 forecast_seed_type: str, timezone, north_angle:float=0, mesh_resolution:float=250) -> Tuple[np.ndarray, float]:
    """Generates a wind forecast using WindNinja.

    This function runs WindNinja with different initialization methods to generate 
    wind forecasts over a given terrain. The forecast is based on elevation, vegetation, 
    and an external wind forecast seed file.

    Args:
        elevation_path (str): Path to the elevation raster file (e.g., a DEM).
        vegetation_path (str): Path to the vegetation type raster file.
        forecast_seed_path (str): Path to the wind seed file (e.g., a weather model output or point data).
        forecast_seed_type (str): Type of wind initialization method. Options:
            - `"Domain Average Wind"`: Uses a single wind value averaged across the domain.
            - `"pointInitialization"`: Uses wind data from a specific point(s) location.
            - `"wxModelInitialization"`: Uses gridded weather model output to initialize the wind field.
        mesh_resolution (float, optional): Grid resolution for WindNinja in meters. Defaults to 250.

    Returns:
        Tuple[np.ndarray, float]: A tuple containing:
            - `forecast` (np.ndarray): The generated wind forecast grid.
            - `time_step` (float): The forecast time step in seconds.

    Notes:
        - The forecast is generated based on WindNinja's simulation outputs.
        - Different initialization methods influence wind patterns significantly.
        - Currently, the `pointInitialization` and `wxModelInitialization` methods 
          call placeholder functions (`run_point_windninja()` and `run_wxmodel_windninja()`), 
          which need implementation.

    TODO:
        - Implement `run_point_windninja()` for point-based wind initialization.
        - Implement `run_wxmodel_windninja()` for weather model initialization.
    """
    forecast = None
    time_step = None

    if forecast_seed_type == "Domain Average Wind":
        # TODO: Add check to make sure this option is only input with a file path
        # Run WindNinja with domain average initialization
        with open(forecast_seed, 'r') as file:
            seed_data = json.load(file)

        forecast, time_step = run_domain_avg_windninja(elevation_path, vegetation_path, seed_data, timezone, north_angle, mesh_resolution)

    elif forecast_seed_type == "OpenMeteo":
        # Run WindNinja on OpenMeteo data
        forecast, time_step = run_domain_avg_windninja(elevation_path, vegetation_path, forecast_seed, timezone, north_angle, mesh_resolution)

    elif forecast_seed_type == "pointInitialization":
        # Run WindNinja with point initialization
        run_point_windninja()

    elif forecast_seed_type == "wxModelInitialization":
        # Run WindNinja with weather model initialization
        run_wxmodel_windninja(elevation_path, vegetation_path, forecast_seed, mesh_resolution)

    return forecast, time_step

def run_domain_avg_windninja(elevation_path: str, vegetation_path: str, seed_data: str, timezone, north_angle: float, mesh_resolution:float=250) -> Tuple[np.ndarray, float]:
    """Runs WindNinja with domain-average initialization to generate a wind forecast.

    This function parses a wind seed file, extracts wind speed and direction data, 
    and runs WindNinja CLI for each time step using a **domain-average wind** initialization. 
    The outputs are processed into a structured wind forecast.

    Args:
        elevation_path (str): Path to the elevation raster file (e.g., a DEM).
        vegetation_path (str): Path to the vegetation type raster file.
        seed_path (str): Path to the wind seed JSON file containing wind speed, 
                         direction, and height data.
        mesh_resolution (float, optional): Resolution of the WindNinja mesh in meters. 
                                           Defaults to 250.

    Returns:
        Tuple[np.ndarray, float]: A tuple containing:
            - `forecast` (np.ndarray): A NumPy array storing the processed wind forecast.
            - `time_step` (float): The time step (in minutes) extracted from the seed file.

    Behavior:
        - Reads the wind seed file and extracts:
            - Wind speed (`speed_m_s`) for each time step.
            - Wind direction, converted to WindNinja’s convention (`(dir + 180) % 360`).
            - Wind height and units.
        - Creates an output directory for each time step and constructs a WindNinja CLI command.
        - Runs WindNinja using `subprocess.run()`, passing parameters such as:
            - Elevation and vegetation files.
            - Mesh resolution.
            - Wind speed, direction, and height.
            - Output format settings.
        - Calls `rename_windninja_outputs()` to standardize output filenames.
        - Calls `create_forecast_array()` to merge the individual outputs into a single forecast array.

    Notes:
        - Wind height information is extracted from the seed file but **not yet fully implemented**.
        - Uses `"domainAverageInitialization"` as the WindNinja initialization method.
        - CLI command assumes `cli_path` is correctly set in the environment.

    TODO:
        - Implement wind height adjustments based on `wind_height` and `wind_height_units`.
        - Validate vegetation file compatibility with WindNinja.
        - Improve error handling for missing or incorrect seed file formats.
    """
    # Extract data from forecast seed
    time_step = seed_data['time_step_min']
    wind_height = seed_data['wind_height']
    wind_height_units = seed_data['wind_height_units']
    input_speed_units = seed_data['wind_speed_units']
    temperature_units = seed_data['temperature_units']
    start_datetime = seed_data['start_datetime']

    # Initialize datetime to track time steps
    curr_datetime = start_datetime


    # Clear temp folder so that new files can be written there
    if os.path.exists(temp_file_path): 
        for file_name in os.listdir(temp_file_path):
            file_path = os.path.join(temp_file_path, file_name)
            if os.path.isfile(file_path):
                os.remove(file_path)
            elif os.path.isdir(file_path):
                for sub_file_name in os.listdir(file_path):
                    sub_file_path = os.path.join(file_path, sub_file_name)
                    if os.path.isfile(sub_file_path):
                        os.remove(sub_file_path)
                os.rmdir(file_path)

    # Write WindNinja outputs for each entry of the wind forecast seed
    for i, entry in enumerate(seed_data['data']):
        os.makedirs(os.path.join(temp_file_path, f"{i}"), exist_ok=True)
        output_path = os.path.join(temp_file_path, f"{i}")

        # Update current date time to next time step
        curr_datetime = start_datetime + timedelta(minutes= i * time_step)

        # Build the WindNinja CLI command
        command = [
            cli_path,
            "--initialization_method", "domainAverageInitialization",
            "--elevation_file", elevation_path,
            "--output_path", output_path, 
            "--vegetation", vegetation_path, # TODO: test with actual vegetation file
            "--mesh_resolution", str(mesh_resolution),
            "--units_mesh_resolution", "m",
            "--time_zone", timezone,
            "--uni_air_temp", str(entry['temperature']),
            "--air_temp_units", temperature_units,
            "--uni_cloud_cover", str(entry['cloud_cover']),
            "--cloud_cover_units", "percent",
            "--diurnal_winds", "false",
            "--year", str(curr_datetime.year),
            "--month", str(curr_datetime.month),
            "--day", str(curr_datetime.day),
            "--hour", str(curr_datetime.hour),
            "--minute", str(curr_datetime.minute),
            "--num_threads", "4",
            "--output_wind_height", "6.1",
            "--units_output_wind_height", "m",
            "--input_speed", str(entry['wind_speed']),
            "--input_speed_units", input_speed_units,
            "--input_direction", str(entry['wind_direction'] + north_angle),
            "--input_wind_height", str(wind_height),
            "--units_input_wind_height", wind_height_units,
            "--write_ascii_output", "true",
            "--write_goog_output", "true"
        ]

        print(f"command: {command}")

        try:
            # Run the WindNinja CLI command
            subprocess.run(command, check=True)

            rename_windninja_outputs(output_path, i)

        except subprocess.CalledProcessError as e:
            print(f"Error running WindNinja CLI: {e}")
    
    # Merge data into a forecast
    forecast = create_forecast_array(len(seed_data['data']))

    return forecast, time_step

def run_point_windninja():
    raise NotImplementedError("Point initialization not yet implemented")

def run_wxmodel_windninja(elevation_path: str, vegetation_path, seed_path, mesh_resolution):
    # Parse the forecast seed
    with open(seed_path, 'r') as file:
        seed_data = json.load(file)

    wx_model_type = seed_data['wx_model_type']
    output_path = temp_file_path
    forecast_time = seed_data['forecast_time']
    forecast_duration = seed_data['forecast_duration']
    time_zone = seed_data['time_zone']

    command = [
        cli_path,
        "--initialization_method", "wxModelInitialization",
        "--elevation_file", elevation_path,
        "--output_path", output_path,
        "--vegetation", vegetation_path, # TODO: need to implement actual files for this
        "--wx_model_type", wx_model_type,
        "--time_zone", time_zone, # TODO: should time zone just use the time zone based on the elevation file location?
        "--forecast_time", forecast_time,  # Format: "YYYYMMDDTHHMMSS"
        "--forecast_duration", str(forecast_duration),
        "--mesh_resolution", str(mesh_resolution),
        "--units_mesh_resolution", "m",
        "--num_threads", "4",
        "--diurnal_winds", "true",
        "--output_wind_height", "6.1",
        "--units_output_wind_height", "m",
        "--write_ascii_output", "true",
        "--write_goog_output", "false"
    ]


    try:
        # Run the WindNinja CLI command
        subprocess.run(command, check=True)

    except subprocess.CalledProcessError as e:
        print(f"Error running WindNinja CLI: {e}")


def rename_windninja_outputs(output_path: str, time_step_index: int):
    """Renames WindNinja output files in a specified directory to a standardized format.

    This function processes WindNinja-generated output files, extracting wind speed, 
    wind direction, and cloud cover data. It renames the files using a structured 
    naming convention based on the provided time step index.

    Args:
        output_path (str): The directory where WindNinja outputs are stored.
        time_step_index (int): The index of the time step to include in the file names.

    Behavior:
        - Identifies files containing `_vel` (wind speed), `_ang` (wind direction), 
          and `_cld` (cloud cover).
        - Renames them to `wind_speed_<time_step>.asc`, `wind_direction_<time_step>.asc`, etc.
        - Ensures all files remain in the same directory.

    Notes:
        - Assumes WindNinja outputs are stored in ASCII format (`.asc`).
        - Cloud cover renaming is included but may not be relevant for all WindNinja runs.
    """
    for file_name in os.listdir(output_path):
        old_path = os.path.join(output_path, file_name)
        if os.path.isfile(old_path):
            # Create a standardized file name
            extension = os.path.splitext(file_name)[1]
            if "_vel" in file_name:
                new_file_name = f"wind_speed_{time_step_index}{extension}"
            elif "_ang" in file_name:
                new_file_name = f"wind_direction_{time_step_index}{extension}"
            elif "_cld" in file_name:
                new_file_name = f"cloud_cover_{time_step_index}{extension}"
            elif extension == ".kmz" or extension == ".kml":
                new_file_name = f"old_path{extension}"

            new_path = os.path.join(output_path, new_file_name)
            os.rename(old_path, new_path)

def create_forecast_array(num_files: int) -> np.ndarray:
    """Loads WindNinja wind forecast outputs into a structured NumPy array.


    This function reads ASCII files produced by WindNinja, extracts wind speed 
    and direction data, and compiles them into a multi-dimensional NumPy array 
    for use in fire simulations.

    Args:
        num_files (int): The number of time steps (i.e., number of WindNinja-generated files).

    Returns:
        np.ndarray: A structured array with shape `(num_files, height, width, 2)`, 
                    where:
                    - `height` and `width` are the dimensions of the wind raster.
                    - The last axis stores wind components:
                        - `[:,:,0]` = Wind speed (m/s).
                        - `[:,:,1]` = Wind direction (converted to Cartesian).

    Behavior:
        - Iterates through each time step’s wind speed and direction files.
        - Loads wind speed (`wind_speed_<i>.asc`) and direction (`wind_direction_<i>.asc`).
        - Converts wind direction data using `convert_to_cartesian()`.
        - Constructs a forecast array with separate wind speed and direction layers.
        - Cleans up temporary WindNinja output directories after processing.

    Notes:
        - Expects WindNinja outputs to follow the standardized naming convention 
          produced by `rename_windninja_outputs()`.
        - Assumes WindNinja output files contain ASCII grid data with a 6-line header.
        - Uses `np.loadtxt()` to efficiently load numerical wind data.
    """

    for i in range(num_files):
        output_path = os.path.join(temp_file_path, f"{i}")

        speed_file = os.path.join(output_path, f"wind_speed_{i}.asc")
        direction_file = os.path.join(output_path, f"wind_direction_{i}.asc")

        if os.path.exists(speed_file) and os.path.exists(direction_file):            
            with open(speed_file, 'r') as file:
                speed_data = np.loadtxt(file, skiprows=6)

                if i == 0:
                    forecast = np.zeros((num_files, *speed_data.shape, 2))

                forecast[i, :, :, 0] = speed_data
            
            with open(direction_file, 'r') as file:
                direction_data = np.loadtxt(file, skiprows=6)
                direction_data = convert_to_cartesian(direction_data)
                forecast[i, :, :, 1] = direction_data

    return forecast

def convert_to_cartesian(direction_data: np.ndarray) -> np.ndarray:
    """Converts wind direction data to a Cartesian-compatible format.

    Wind direction in WindNinja outputs is typically measured in meteorological degrees 
    (0° = North-South, 90° = East-West, 180° = South-North, 270° = West-East). This function adjusts the values 
    to align with a Cartesian coordinate system.

    Args:
        direction_data (np.ndarray): A NumPy array containing wind direction values in degrees.

    Returns:
        np.ndarray: The transformed wind direction data, where:

            direction_cartesian = (180 + direction_data) % 360

    Notes:
        - This transformation ensures compatibility with fire spread models that 
          use Cartesian angle conventions.
        - Assumes wind direction values are given in degrees (0-360).
    """
    return (180 + direction_data) % 360