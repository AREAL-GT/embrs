import subprocess
import os
import json
import numpy as np
from typing import Tuple

# Path to the WindNinja CLI executable # TODO: need a way to populate this for other users
cli_path = "/Users/rui/Documents/Research/Code/wind/build/src/cli/WindNinja_cli"

# Path to store temporary files generated by WindNinja # TODO: populate this based on location of CLI executable
temp_file_path = "/Users/rui/Documents/Research/Code/wind/build/src/cli/temp"

def gen_forecast(elevation_path: str, vegetation_path: str, forecast_seed_path: str,
                 forecast_seed_type: str, mesh_resolution:float=250) -> Tuple[np.ndarray, float]:
    """_summary_

    Args:
        elevation_path (str): _description_
        vegetation_path (str): _description_
        forecast_seed_path (str): _description_
        forecast_seed_type (str): _description_
        mesh_resolution (float, optional): _description_. Defaults to 250.

    Returns:
        Tuple[np.ndarray, float]: _description_
    """

    forecast = None
    time_step = None

    if forecast_seed_type == "Domain Average Wind":
        # Run WindNinja with domain average initialization
        forecast, time_step = run_domain_avg_windninja(elevation_path, vegetation_path, forecast_seed_path, mesh_resolution)

    elif forecast_seed_type == "pointInitialization":
        # Run WindNinja with point initialization
        run_point_windninja()

    elif forecast_seed_type == "wxModelInitialization":
        # Run WindNinja with weather model initialization
        run_wxmodel_windninja()


    return forecast, time_step

def run_domain_avg_windninja(elevation_path: str, vegetation_path: str, seed_path: str, mesh_resolution:float=250) -> Tuple[np.ndarray, float]:
    """_summary_

    Args:
        elevation_path (str): _description_
        vegetation_path (str): _description_
        seed_path (str): _description_
        mesh_resolution (float, optional): _description_. Defaults to 250.

    Returns:
        Tuple[np.ndarray, float]: _description_
    """
    # Parse the forecast seed
    # Load wind forecast and initialize wind vector
    with open(seed_path, 'r') as file:
        seed_data = json.load(file)

    time_step = seed_data['time_step_min']
    speed_list = []
    direction_list = []
    for entry in seed_data['data']:
        speed_list.append(entry['speed_m_s'])

        # Convert direction to WindNinja convention
        direction = (entry['direction'] + 180) % 360
        direction_list.append(direction)

    # TODO: Implement wind height in wind forecast seed generation
    wind_height = seed_data['wind_height']
    wind_height_units = seed_data['wind_height_units']

    for i, (speed, direction) in enumerate(zip(speed_list, direction_list)):
        os.makedirs(os.path.join(temp_file_path, f"{i}"), exist_ok=True)
        output_path = os.path.join(temp_file_path, f"{i}")

        # Build the WindNinja CLI command
        command = [
            cli_path,
            "--initialization_method", "domainAverageInitialization",
            "--elevation_file", elevation_path,
            "--output_path", output_path, 
            "--vegetation", vegetation_path, # TODO: test with actual vegetation file
            "--mesh_resolution", str(mesh_resolution),
            "--units_mesh_resolution", "m",
            "--num_threads", "4",
            "--output_wind_height", "6.1",
            "--units_output_wind_height", "m",
            "--input_speed", str(speed),
            "--input_speed_units", "mps",
            "--input_direction", str(direction),
            "--input_wind_height", str(wind_height),
            "--units_input_wind_height", wind_height_units,
            "--write_ascii_output", "true"
        ]

        try:
            # Run the WindNinja CLI command
            subprocess.run(command, check=True)

            rename_windninja_outputs(output_path, i)

        except subprocess.CalledProcessError as e:
            print(f"Error running WindNinja CLI: {e}")
    
    # Merge data into a forecast
    forecast = create_forecast_array(len(speed_list))

    return forecast, time_step

def run_point_windninja():
    raise NotImplementedError("Point initialization not yet implemented")


def run_wxmodel_windninja():
    raise NotImplementedError("Weather model initialization not yet implemented")

def rename_windninja_outputs(output_path: str, time_step_index: int):
    """
    Rename WindNinja output files in the specified directory to a standard format.

    :param output_path: Directory where WindNinja outputs are stored.
    :type output_path: str
    :param time_step_index: Time step index to include in the file names.
    :type time_step_index: int
    """
    for file_name in os.listdir(output_path):
        old_path = os.path.join(output_path, file_name)
        if os.path.isfile(old_path):
            # Create a standardized file name
            extension = os.path.splitext(file_name)[1]
            if "_vel" in file_name:
                new_file_name = f"wind_speed_{time_step_index}{extension}"
            elif "_ang" in file_name:
                new_file_name = f"wind_direction_{time_step_index}{extension}"
            elif "_cld" in file_name:
                new_file_name = f"cloud_cover_{time_step_index}{extension}"

            new_path = os.path.join(output_path, new_file_name)
            os.rename(old_path, new_path)

def create_forecast_array(num_files: int) -> np.ndarray:
    """_summary_

    Args:
        num_files (int): _description_

    Returns:
        np.ndarray: _description_
    """
    for i in range(num_files):
        output_path = os.path.join(temp_file_path, f"{i}")

        speed_file = os.path.join(output_path, f"wind_speed_{i}.asc")
        direction_file = os.path.join(output_path, f"wind_direction_{i}.asc")

        if os.path.exists(speed_file) and os.path.exists(direction_file):            
            with open(speed_file, 'r') as file:
                speed_data = np.loadtxt(file, skiprows=6)

                if i == 0:
                    forecast = np.zeros((num_files, *speed_data.shape, 2))

                forecast[i, :, :, 0] = speed_data
            
            with open(direction_file, 'r') as file:
                direction_data = np.loadtxt(file, skiprows=6)
                direction_data = convert_to_cartesian(direction_data)
                forecast[i, :, :, 1] = direction_data
    
    # Delete the temporary directories after data is gathered
    print("Removing temporary files...")
    for i in range(num_files):
        output_path = os.path.join(temp_file_path, f"{i}")
        if os.path.exists(output_path):
            for file_name in os.listdir(output_path):
                file_path = os.path.join(output_path, file_name)
                if os.path.isfile(file_path):
                    os.remove(file_path)
            os.rmdir(output_path)

    return forecast

def convert_to_cartesian(direction_data: np.ndarray) -> np.ndarray:
    """_summary_

    Args:
        direction_data (np.ndarray): _description_

    Returns:
        np.ndarray: _description_
    """
    return (180 + direction_data) % 360