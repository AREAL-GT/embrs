"""Wind forecast processing using WindNinja.

This module provides functions for generating and processing wind forecasts using WindNinja. 
It supports different initialization methods, handles WindNinja CLI execution, and structures 
wind data into NumPy arrays for use in wildfire simulations.

Features:
    - **Wind Forecast Generation**:
        - `gen_forecast()`: Runs WindNinja with domain-average, point-based, or weather model initialization.
        - `run_domain_avg_windninja()`: Executes WindNinja using domain-average wind initialization.
        - `run_point_windninja()`: Placeholder for point-based wind initialization.
        - `run_wxmodel_windninja()`: Placeholder for weather model-based wind initialization.

    - **Wind Data Processing**:
        - `rename_windninja_outputs()`: Renames WindNinja-generated files to a standardized format.
        - `create_forecast_array()`: Loads WindNinja outputs into a structured NumPy array.
        - `convert_to_cartesian()`: Converts wind direction data from meteorological to Cartesian convention.

Dependencies:
    - **External Software**: WindNinja CLI must be installed and accessible at `cli_path`.
    - **Python Libraries**: Requires `subprocess`, `os`, `json`, `numpy`, and `typing`.

Paths:
    - `cli_path`: Path to the WindNinja CLI executable. **(TODO: Make user-configurable)**
    - `temp_file_path`: Path for storing temporary WindNinja outputs. **(TODO: Set dynamically based on `cli_path`)**

Usage:
    To generate a wind forecast using a domain-average wind:
    ```python
    forecast, time_step = gen_forecast(
        elevation_path="path/to/elevation.asc",
        vegetation_path="path/to/vegetation.asc",
        forecast_seed_path="path/to/wind_seed.json",
        forecast_seed_type="Domain Average Wind"
    )
    ```
"""

import subprocess
import os
import json
import numpy as np
from typing import Tuple
from multiprocessing import cpu_count, Pool
from tqdm import tqdm
from dataclasses import dataclass
from datetime import timedelta

# Path to the WindNinja CLI executable # TODO: need a way to populate this for other users
cli_path = "/Users/rui/Documents/Research/Code/wind/build/src/cli/WindNinja_cli"

# Path to store temporary files generated by WindNinja # TODO: populate this based on location of CLI executable
temp_file_path = "/Users/rui/Documents/Research/Code/wind/build/src/cli/temp"

@dataclass
class WindNinjaTask:
    index: int
    time_step: float
    entry: dict
    elevation_path: str
    vegetation_path: str
    timezone: str
    north_angle: float
    mesh_resolution: float
    temp_file_path: str
    cli_path: str
    start_datetime: timedelta
    wind_height: float
    wind_height_units: str
    input_speed_units: str
    temperature_units: str

def gen_forecast(elevation_path: str, vegetation_path: str, forecast_seed,
                 forecast_seed_type: str, timezone, north_angle:float=0, mesh_resolution:float=250) -> Tuple[np.ndarray, float]:
    """Generates a wind forecast using WindNinja.

    This function runs WindNinja with different initialization methods to generate 
    wind forecasts over a given terrain. The forecast is based on elevation, vegetation, 
    and an external wind forecast seed file.

    Args:
        elevation_path (str): Path to the elevation raster file (e.g., a DEM).
        vegetation_path (str): Path to the vegetation type raster file.
        forecast_seed_path (str): Path to the wind seed file (e.g., a weather model output or point data).
        forecast_seed_type (str): Type of wind initialization method. Options:
            - `"Domain Average Wind"`: Uses a single wind value averaged across the domain.
            - `"pointInitialization"`: Uses wind data from a specific point(s) location.
            - `"wxModelInitialization"`: Uses gridded weather model output to initialize the wind field.
        mesh_resolution (float, optional): Grid resolution for WindNinja in meters. Defaults to 250.

    Returns:
        Tuple[np.ndarray, float]: A tuple containing:
            - `forecast` (np.ndarray): The generated wind forecast grid.
            - `time_step` (float): The forecast time step in seconds.

    Notes:
        - The forecast is generated based on WindNinja's simulation outputs.
        - Different initialization methods influence wind patterns significantly.
        - Currently, the `pointInitialization` and `wxModelInitialization` methods 
          call placeholder functions (`run_point_windninja()` and `run_wxmodel_windninja()`), 
          which need implementation.

    TODO:
        - Implement `run_point_windninja()` for point-based wind initialization.
        - Implement `run_wxmodel_windninja()` for weather model initialization.
    """
    forecast = None
    time_step = None

    if forecast_seed_type == "Domain Average Wind":
        # TODO: Add check to make sure this option is only input with a file path
        # Run WindNinja with domain average initialization
        with open(forecast_seed, 'r') as file:
            seed_data = json.load(file)

        forecast, time_step = run_domain_avg_windninja(elevation_path, vegetation_path, seed_data, timezone, north_angle, mesh_resolution)

    elif forecast_seed_type == "OpenMeteo":
        # Run WindNinja on OpenMeteo data
        forecast, time_step = run_domain_avg_windninja(elevation_path, vegetation_path, forecast_seed, timezone, north_angle, mesh_resolution)

    elif forecast_seed_type == "pointInitialization":
        # Run WindNinja with point initialization
        run_point_windninja()

    elif forecast_seed_type == "wxModelInitialization":
        # Run WindNinja with weather model initialization
        run_wxmodel_windninja(elevation_path, vegetation_path, forecast_seed, mesh_resolution)

    return forecast, time_step

def run_windninja_single(task: WindNinjaTask):
    """Runs WindNinja for a single time step in parallel."""
    output_path = os.path.join(temp_file_path, f"{task.index}")
    os.makedirs(output_path, exist_ok=True)

    curr_datetime = task.start_datetime + timedelta(minutes=task.index * task.time_step)

    command = [
        cli_path,
        "--initialization_method", "domainAverageInitialization",
        "--elevation_file", task.elevation_path,
        "--output_path", output_path,
        "--vegetation", task.vegetation_path,
        "--mesh_resolution", str(task.mesh_resolution),
        "--units_mesh_resolution", "m",
        "--time_zone", task.timezone,
        "--uni_air_temp", str(task.entry['temperature']),
        "--air_temp_units", task.temperature_units,
        "--uni_cloud_cover", str(task.entry['cloud_cover']),
        "--cloud_cover_units", "percent",
        "--diurnal_winds", "false",
        "--year", str(curr_datetime.year),
        "--month", str(curr_datetime.month),
        "--day", str(curr_datetime.day),
        "--hour", str(curr_datetime.hour),
        "--minute", str(curr_datetime.minute),
        "--num_threads", "4",
        "--output_wind_height", "6.1",
        "--units_output_wind_height", "m",
        "--input_speed", str(task.entry['wind_speed']),
        "--input_speed_units", task.input_speed_units,
        "--input_direction", str(task.entry['wind_direction'] + task.north_angle),
        "--input_wind_height", str(task.wind_height),
        "--units_input_wind_height", task.wind_height_units,
        "--write_ascii_output", "true",
        "--write_goog_output", "true"
    ]

    try:
        log_file = os.path.join(output_path, "windninja_log.txt")

        with open(log_file, "w") as file:
            subprocess.run(command, check=True, stdout=file, stderr=file) # TODO: is the HTTP 500 error ok?
        
        rename_windninja_outputs(output_path, task.index)

    except subprocess.CalledProcessError as e:
        print(f"Error running WindNinja CLI at step {task.index}: {e}")

def run_domain_avg_windninja(elevation_path: str, vegetation_path: str, seed_data: dict, timezone, north_angle: float, mesh_resolution: float = 250) -> Tuple[np.ndarray, float]:
    """Runs WindNinja with domain-average initialization in parallel."""
    
    # Extract data from forecast seed
    time_step = seed_data['time_step_min']
    wind_height = seed_data['wind_height']
    wind_height_units = seed_data['wind_height_units']
    input_speed_units = seed_data['wind_speed_units']
    temperature_units = seed_data['temperature_units']
    start_datetime = seed_data['start_datetime']

    # Clear temp folder
    if os.path.exists(temp_file_path):
        for file_name in os.listdir(temp_file_path):
            file_path = os.path.join(temp_file_path, file_name)
            if os.path.isfile(file_path):
                os.remove(file_path)
            elif os.path.isdir(file_path):
                for sub_file_name in os.listdir(file_path):
                    sub_file_path = os.path.join(file_path, sub_file_name)
                    if os.path.isfile(sub_file_path):
                        os.remove(sub_file_path)
                os.rmdir(file_path)

    # Prepare arguments for parallel execution
    tasks = [
        WindNinjaTask(
            index=i,
            time_step=time_step,
            entry=entry,
            elevation_path=elevation_path,
            vegetation_path=vegetation_path,
            timezone=timezone,
            north_angle=north_angle,
            mesh_resolution=mesh_resolution,
            temp_file_path=temp_file_path,
            cli_path=cli_path,
            start_datetime=start_datetime,
            wind_height=wind_height,
            wind_height_units=wind_height_units,
            input_speed_units=input_speed_units,
            temperature_units=temperature_units
        )
        for i, entry in enumerate(seed_data['data'])
    ]
    # Use multiprocessing Pool to parallelize
    num_workers = min(cpu_count(), len(tasks))  # Limit workers to available CPU cores

    pool = Pool(processes=num_workers)

    for _ in tqdm(pool.imap_unordered(run_windninja_single, tasks), total = len(tasks), desc="Generating wind with WindNinja: "):
        pass
    
    # Merge data into a forecast
    forecast = create_forecast_array(len(seed_data['data']))

    return forecast, time_step

def run_point_windninja():
    raise NotImplementedError("Point initialization not yet implemented")

def run_wxmodel_windninja(elevation_path: str, vegetation_path, seed_path, mesh_resolution):
    # Parse the forecast seed
    with open(seed_path, 'r') as file:
        seed_data = json.load(file)

    wx_model_type = seed_data['wx_model_type']
    output_path = temp_file_path
    forecast_time = seed_data['forecast_time']
    forecast_duration = seed_data['forecast_duration']
    time_zone = seed_data['time_zone']

    command = [
        cli_path,
        "--initialization_method", "wxModelInitialization",
        "--elevation_file", elevation_path,
        "--output_path", output_path,
        "--vegetation", vegetation_path, # TODO: need to implement actual files for this
        "--wx_model_type", wx_model_type,
        "--time_zone", time_zone, # TODO: should time zone just use the time zone based on the elevation file location?
        "--forecast_time", forecast_time,  # Format: "YYYYMMDDTHHMMSS"
        "--forecast_duration", str(forecast_duration),
        "--mesh_resolution", str(mesh_resolution),
        "--units_mesh_resolution", "m",
        "--num_threads", "4",
        "--diurnal_winds", "true",
        "--output_wind_height", "6.1",
        "--units_output_wind_height", "m",
        "--write_ascii_output", "true",
        "--write_goog_output", "false"
    ]

    try:
        # Run the WindNinja CLI command
        subprocess.run(command, check=True)

    except subprocess.CalledProcessError as e:
        print(f"Error running WindNinja CLI: {e}")


def rename_windninja_outputs(output_path: str, time_step_index: int):
    """Renames WindNinja output files in a specified directory to a standardized format.

    This function processes WindNinja-generated output files, extracting wind speed, 
    wind direction, and cloud cover data. It renames the files using a structured 
    naming convention based on the provided time step index.

    Args:
        output_path (str): The directory where WindNinja outputs are stored.
        time_step_index (int): The index of the time step to include in the file names.

    Behavior:
        - Identifies files containing `_vel` (wind speed), `_ang` (wind direction), 
          and `_cld` (cloud cover).
        - Renames them to `wind_speed_<time_step>.asc`, `wind_direction_<time_step>.asc`, etc.
        - Ensures all files remain in the same directory.

    Notes:
        - Assumes WindNinja outputs are stored in ASCII format (`.asc`).
        - Cloud cover renaming is included but may not be relevant for all WindNinja runs.
    """
    for file_name in os.listdir(output_path):
        old_path = os.path.join(output_path, file_name)
        if os.path.isfile(old_path):
            # Create a standardized file name
            extension = os.path.splitext(file_name)[1]
            if "_vel" in file_name:
                new_file_name = f"wind_speed_{time_step_index}{extension}"
            elif "_ang" in file_name:
                new_file_name = f"wind_direction_{time_step_index}{extension}"
            elif "_cld" in file_name:
                new_file_name = f"cloud_cover_{time_step_index}{extension}"
            elif extension == ".kmz" or extension == ".kml":
                new_file_name = f"old_path{extension}"
            else:
                continue

            new_path = os.path.join(output_path, new_file_name)
            os.rename(old_path, new_path)

def create_forecast_array(num_files: int) -> np.ndarray:
    """Loads WindNinja wind forecast outputs into a structured NumPy array.


    This function reads ASCII files produced by WindNinja, extracts wind speed 
    and direction data, and compiles them into a multi-dimensional NumPy array 
    for use in fire simulations.

    Args:
        num_files (int): The number of time steps (i.e., number of WindNinja-generated files).

    Returns:
        np.ndarray: A structured array with shape `(num_files, height, width, 2)`, 
                    where:
                    - `height` and `width` are the dimensions of the wind raster.
                    - The last axis stores wind components:
                        - `[:,:,0]` = Wind speed (m/s).
                        - `[:,:,1]` = Wind direction (converted to Cartesian).

    Behavior:
        - Iterates through each time step’s wind speed and direction files.
        - Loads wind speed (`wind_speed_<i>.asc`) and direction (`wind_direction_<i>.asc`).
        - Converts wind direction data using `convert_to_cartesian()`.
        - Constructs a forecast array with separate wind speed and direction layers.
        - Cleans up temporary WindNinja output directories after processing.

    Notes:
        - Expects WindNinja outputs to follow the standardized naming convention 
          produced by `rename_windninja_outputs()`.
        - Assumes WindNinja output files contain ASCII grid data with a 6-line header.
        - Uses `np.loadtxt()` to efficiently load numerical wind data.
    """

    for i in range(num_files):
        output_path = os.path.join(temp_file_path, f"{i}")

        speed_file = os.path.join(output_path, f"wind_speed_{i}.asc")
        direction_file = os.path.join(output_path, f"wind_direction_{i}.asc")

        if os.path.exists(speed_file) and os.path.exists(direction_file):            
            with open(speed_file, 'r') as file:
                speed_data = np.loadtxt(file, skiprows=6)

                if i == 0:
                    forecast = np.zeros((num_files, *speed_data.shape, 2))

                forecast[i, :, :, 0] = speed_data
            
            with open(direction_file, 'r') as file:
                direction_data = np.loadtxt(file, skiprows=6)
                direction_data = convert_to_cartesian(direction_data)
                forecast[i, :, :, 1] = direction_data

    return forecast

def convert_to_cartesian(direction_data: np.ndarray) -> np.ndarray:
    """Converts wind direction data to a Cartesian-compatible format.

    Wind direction in WindNinja outputs is typically measured in meteorological degrees 
    (0° = North-South, 90° = East-West, 180° = South-North, 270° = West-East). This function adjusts the values 
    to align with a Cartesian coordinate system.

    Args:
        direction_data (np.ndarray): A NumPy array containing wind direction values in degrees.

    Returns:
        np.ndarray: The transformed wind direction data, where:

            direction_cartesian = (180 + direction_data) % 360

    Notes:
        - This transformation ensures compatibility with fire spread models that 
          use Cartesian angle conventions.
        - Assumes wind direction values are given in degrees (0-360).
    """
    return (180 + direction_data) % 360