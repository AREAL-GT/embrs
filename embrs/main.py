"""Module containing code that loads parameters from user input and runs the simulations
"""
from time import time
import signal
import importlib
import sys
import copy
import json
import os
import pickle
from typing import Tuple
from tqdm import tqdm
import argparse
import configparser
from datetime import datetime
from embrs.fire_simulator.visualizer import Visualizer
from embrs.fire_simulator.logger import Logger
from embrs.fire_simulator.fire import FireSim
from embrs.utilities.file_io import SimFolderSelector, LoaderWindow
from embrs.utilities.fire_util import UtilFuncs
from embrs.base_classes.control_base import ControlClass
from embrs.utilities.data_classes import SimParams, WeatherParams

def initialize(sim_params: SimParams) -> Tuple[FireSim, bool, Visualizer]:
    """Initializes a fireSim object and a Visualizer(if selected) based on user inputs

    :param params: dictionary containing all user's inputs and preferenes, generated by
                   SimFolderSelector class.
    :type params: dict
    :return: tuple containing a FireSim object, a bool variable specifying if real-time 
             visualization was selected, and a Visualizer object. If real-time visualization not
             selected Visualizer will be None.
    :rtype: Tuple[FireSim, bool, Visualizer]
    """

    # Initialize the simulator
    fire = FireSim(sim_params)

    # Initialize the visualizer, if visualization is selected
    if sim_params.visualize:
        viz = Visualizer(fire)
    else:
        viz = None

    return fire, sim_params.visualize, viz

def run_sim(fire: FireSim, viz: Visualizer, progress_bar: tqdm, loader_window: LoaderWindow,
            viz_on: bool, user_code_path: str, user_code_class: str, i:int, num_runs:int):
    """Function that runs the fire simulation and user code. Runs until the sim duration is reached
    or the fire is extinguished.

    :param fire: FireSim object to be run
    :type fire: FireSim
    :param viz: Visualizer object used for real-time visualization
    :type viz: Visualizer
    :param progress_bar: tqdm progress bar for command line display
    :type progress_bar: tqdm
    :param loader_window: LoaderWindow object used for generating a tk window that displays 
                          progress
    :type loader_window: LoaderWindow
    :param viz_on: boolean variable specifying whether the sim should be displayed in real-time
                   or not
    :type viz_on: bool
    :param user_code_path: Path to the user's selected module to run in parallel with sim
    :type user_code_path: str
    :param user_code_class: Name of the user's selected class to run in parallel with sim
    :type user_code_class: str
    :param i: Current number of simulation running
    :type i: int
    :param num_runs: Number of total simulations to be run
    :type num_runs: int
    """
    start = time()

    time_since_last_update = 20
    last_update = 0

    if user_code_path == "":
        user = None
    else:
        # Strip the extension and path
        user_module_name = os.path.splitext(os.path.basename(user_code_path))[0]

        # Dynamically import the module
        user_module = importlib.import_module(user_module_name)

        # Access the class within the module
        UserCodeClass = getattr(user_module, user_code_class)

        # Check if the user's class is a subclass of the abstract base class
        if not issubclass(UserCodeClass, ControlClass):
            raise TypeError(f"{user_code_class} is not a subclass of ControlClass")

        user = UserCodeClass(fire)  # Construct the user object

    if fire.logger:
        fire.logger.start_status_log()

    while not fire.finished:

        fire.iterate()

        if user:
            user.process_state(fire)

        progress_bar.update()
        loader_window.increment_progress()

        # ----------- Perform real-time plotting ------------- #
        if viz_on:
            time_since_last_update = fire.curr_time_s - last_update

            if time_since_last_update >= fire.display_frequency:
                viz.update_grid(fire)
                last_update = fire.curr_time_s

    iters_skipped = ((fire.sim_duration/fire.time_step) + 1) - fire.iters
    progress_bar.update(iters_skipped)
    loader_window.increment_progress(increment_value=iters_skipped)
    end = time()
    elapsed = end - start

    msg = (f"Simulation complete. Sim time: {UtilFuncs.get_time_str(fire.curr_time_s)}, "
        f"took {UtilFuncs.get_time_str(elapsed, True)} seconds to compute.")

    if fire.logger:
        fire.logger.log_message(msg)

    loader_window.set_text(f"Saving log file for simulation ({i+1}/{num_runs})")
    
    if fire.logger:
        fire.logger.finish(fire)

def handle_interrupt(logger, fire):
    """Function to handle user interrupts while a sim is running.
    """
    if logger is not None:
        print("\nUser interrupt detected. Finalizing logging...")
        logger.finish(fire, True)
    else:
        sys.exit(0)

def sim_loop(sim_params: SimParams):
    """Main function that gets user input from GUI and runs the specified simulation(s)
    """
    num_runs = sim_params.num_runs 
    duration = sim_params.duration_s
    time_step = sim_params.t_step_s

    # Get user code info
    user_code_path = sim_params.user_path
    user_code_class = sim_params.user_class

    # Create loader window object
    loader_window = LoaderWindow('Fire sim', max_value=num_runs*(duration/time_step)+1)
    loader_window.set_text("Initializing simulations...")

    fire, viz_on, viz = initialize(sim_params)

    if sim_params.write_logs:
        data_logger = Logger(sim_params.log_folder)
        # TODO: need to rewrite these when we rewrite logger
        # data_logger.store_metadata(params, fire)
        # data_logger.store_init_fire_obj(fire)

    else:
        data_logger = None


    print("Running simulations... ")
    print("")

    # Create command line progress bar
    progress_bar = tqdm(total=(num_runs*(fire.sim_duration/fire.time_step)),
                        desc='Total progress', position=1, leave=True)

    curr_fire = None

    for i in range(num_runs):
        if num_runs > 1:
            curr_fire = copy.deepcopy(fire)

        else:
            curr_fire = fire

        # Register the signal handler
        signal.signal(signal.SIGINT, lambda signum, frame: handle_interrupt(data_logger, curr_fire))

        curr_fire.logger = data_logger
        loader_window.set_text(f"Running simulation ({i+1}/{num_runs})")
        run_sim(curr_fire, viz, progress_bar, loader_window, viz_on, user_code_path,
                user_code_class, i, num_runs)

        if viz_on:
            viz.reset_figure(done = i==num_runs-1)

    progress_bar.close()
    loader_window.set_text(f"Finished running {num_runs} simulations(s)")
    loader_window.close()

    print("")
    print(f"Finished running {num_runs} simulation(s)")

def load_sim_params(cfg_path: str) -> SimParams:
    """Load simulation parameters from .cfg file"""
    config = configparser.ConfigParser()
    config.read(cfg_path)

    # Parse Map Data
    map_params = None
    if "Map" in config:
        folder = config["Map"]["folder"]
        pkl_path = os.path.join(folder, "map_params.pkl")

        print(f"pkl_path: {pkl_path}")

        if os.path.exists(pkl_path):
            with open(pkl_path, "rb") as f:
                map_params = pickle.load(f)
        else:
            raise FileNotFoundError(f"Error in {cfg_path}: MapParams file not found in '{folder}'. Ensure 'map_params.pkl' exists.")
    else:
        raise ValueError(f"Error in {cfg_path}: Missing 'Map' section in the .cfg file.")

    # Parse weather data
    weather_input_type = config["Weather"].get("input_type", None)

    if weather_input_type is None:
        raise ValueError(f"Error in {cfg_path}: 'input_type' must be specified in the [Weather] section.")

    mesh_resolution = config["Weather"].getint("mesh_resolution", None)

    if mesh_resolution is None:
        mesh_resolution = 250
        print(f"Warning: Mesh resolution for WindNinja not specified in {cfg_path}, defaulting to 250m.")

    start_iso_datetime = config["Weather"].get("start_datetime", None)
    end_iso_datetime = config["Weather"].get("end_datetime", None)

    if start_iso_datetime is None or end_iso_datetime is None:
        raise ValueError(f"Error in {cfg_path}: Both 'start_datetime' and 'end_datetime' must be specified in the [Weather] section.")

    weather_params = WeatherParams(
        input_type=weather_input_type,
        file=config["Weather"].get("file", None),
        mesh_resolution=mesh_resolution,
        start_datetime=datetime.fromisoformat(start_iso_datetime),
        end_datetime=datetime.fromisoformat(end_iso_datetime),
    )

    write_logs = config["Simulation"].getboolean("write_logs", None)
    log_folder = config["Simulation"].get("log_folder", None)

    if write_logs is None:
        if log_folder is None:
            write_logs = False
        else:
            write_logs = True
    elif write_logs and log_folder is None:
        raise ValueError(f"Error in {cfg_path}: 'log_folder' must be specified if 'write_logs' is set to True.")

    detect_duration = config["Simulation"].getboolean("detect_duration", None)
    duration_s = config["Simulation"].getint("duration_s", None)

    if detect_duration is None:
        if duration_s is None:
            detect_duration = True
            print(f"Warning: No 'duration_s' specified in {cfg_path}. Defaulting to the time difference between start and end datetimes.")
        else:
            detect_duration = False

    elif detect_duration and duration_s is not None:
        raise ValueError(f"Error in {cfg_path}: 'detect_duration' cannot be True while 'duration_s' is specified.")
    
    elif not detect_duration and duration_s is None:
        raise ValueError(f"Error in {cfg_path}: either 'detect_duration' must be True or 'duration_s' needs to be specified.")

    if weather_params.start_datetime >= weather_params.end_datetime:
        raise ValueError(f"Error in {cfg_path}: Start datetime must be before end datetime.")

    if detect_duration:
        if weather_input_type == "OpenMeteo":
            duration = weather_params.end_datetime - weather_params.start_datetime
            duration_s = duration.total_seconds()
        elif weather_input_type == "File":
            with open(weather_params.file, "rb") as f:
                weather = json.load(f)

            # get duration from number of entries
            weather_time_step_min = weather['time_step_min']
            weather_time_step_hr = weather_time_step_min / 60
            num_entries = len(weather['weather entries'])
            duration_s = weather_time_step_hr * num_entries * 3600

    t_step_s = config["Simulation"].getint("t_step_s", None)
    if t_step_s is None:
        raise ValueError(f"Error in {cfg_path}: 't_step_s' (time step) must be specified in the [Simulation] section.")

    cell_size = config["Simulation"].getint("cell_size", None)
    if cell_size is None:
        raise ValueError(f"Error in {cfg_path}: 'cell_size' must be specified in the [Simulation] section.")

    user_class = config["Simulation"].get("user_class", None)
    user_path = config["Simulation"].get("user_path", None)

    if user_class is None or user_path is None:
        user_class = ""
        user_path = ""

    sim_params = SimParams(
        map_params=map_params,
        log_folder=log_folder,
        weather_input=weather_params,
        t_step_s=t_step_s,
        duration_s=duration_s,
        cell_size=cell_size,
        num_runs=config["Simulation"].getint("num_runs", 1),
        visualize=config["Simulation"].getboolean("visualize", False),
        user_path=user_path,
        user_class=user_class,
    )

    return sim_params

def main():

    parser = argparse.ArgumentParser(description="Run fire simulation")
    parser.add_argument("--config", type=str, help="Path to .cfg file")

    args = parser.parse_args()

    if args.config:
        print(f"Loading simulation params from {args.config}...")
        sim_params = load_sim_params(args.config)

        sim_loop(sim_params)

    else:
        print("Starting sim initialization GUI...")
        folder_selector = SimFolderSelector(sim_loop)
        folder_selector.run()

if __name__ == "__main__":
    main()
