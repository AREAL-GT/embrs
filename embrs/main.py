"""Module containing code that loads parameters from user input and runs the simulations
"""
from time import time
import signal
import importlib
import sys
import copy
import json
import os
import pickle
from typing import Tuple
from tqdm import tqdm
import argparse
import configparser
from datetime import datetime, timedelta
from embrs.fire_simulator.visualizer import RealTimeVisualizer
from embrs.utilities.logger import Logger
from embrs.fire_simulator.fire import FireSim
from embrs.utilities.file_io import SimFolderSelector, LoaderWindow
from embrs.utilities.fire_util import UtilFuncs
from embrs.base_classes.control_base import ControlClass
from embrs.utilities.data_classes import SimParams, WeatherParams

def initialize(sim_params: SimParams) -> Tuple[FireSim, bool, RealTimeVisualizer]:
    """Initializes a fireSim object and a Visualizer(if selected) based on user inputs

    :param params: dictionary containing all user's inputs and preferenes, generated by
                   SimFolderSelector class.
    :type params: dict
    :return: tuple containing a FireSim object, a bool variable specifying if real-time 
             visualization was selected, and a Visualizer object. If real-time visualization not
             selected Visualizer will be None.
    :rtype: Tuple[FireSim, bool, Visualizer]
    """

    # Initialize the simulator
    fire = FireSim(sim_params)

    # Initialize the visualizer, if visualization is selected
    if sim_params.visualize:
        viz = RealTimeVisualizer(fire)
        fire.set_visualizer(viz)
    else:
        viz = None

    return fire, sim_params.visualize, viz

def run_sim(fire: FireSim, viz: RealTimeVisualizer, progress_bar: tqdm, loader_window: LoaderWindow,
            viz_on: bool, user_code_path: str, user_code_class: str, i:int, num_runs:int):
    """Function that runs the fire simulation and user code. Runs until the sim duration is reached
    or the fire is extinguished.

    :param fire: FireSim object to be run
    :type fire: FireSim
    :param viz: Visualizer object used for real-time visualization
    :type viz: Visualizer
    :param progress_bar: tqdm progress bar for command line display
    :type progress_bar: tqdm
    :param loader_window: LoaderWindow object used for generating a tk window that displays 
                          progress
    :type loader_window: LoaderWindow
    :param viz_on: boolean variable specifying whether the sim should be displayed in real-time
                   or not
    :type viz_on: bool
    :param user_code_path: Path to the user's selected module to run in parallel with sim
    :type user_code_path: str
    :param user_code_class: Name of the user's selected class to run in parallel with sim
    :type user_code_class: str
    :param i: Current number of simulation running
    :type i: int
    :param num_runs: Number of total simulations to be run
    :type num_runs: int
    """
    start = time()

    if fire.logger:
        fire.logger.start_new_run()

    time_since_last_update = 20
    last_update = 0

    if user_code_path == "":
        user = None
    else:
        user_module_dir = os.path.dirname(user_code_path)
        if user_module_dir not in sys.path:
            sys.path.insert(0, user_module_dir)

        # Strip the extension and path
        user_module_name = os.path.splitext(os.path.basename(user_code_path))[0]

        # Dynamically import the module
        user_module = importlib.import_module(user_module_name)

        # Access the class within the module
        UserCodeClass = getattr(user_module, user_code_class)

        # Check if the user's class is a subclass of the abstract base class
        if not issubclass(UserCodeClass, ControlClass):
            raise TypeError(f"{user_code_class} is not a subclass of ControlClass")

        user = UserCodeClass(fire)  # Construct the user object

    while not fire.finished:

        fire.iterate()

        if user:
            user.process_state(fire)

        progress_bar.update()
        loader_window.increment_progress()

        # ----------- Perform real-time plotting ------------- #
        if viz_on:
            time_since_last_update = fire.curr_time_s - last_update

            if time_since_last_update >= fire.display_frequency:
                viz.update()
                last_update = fire.curr_time_s

    iters_skipped = ((fire.sim_duration/fire.time_step) + 1) - fire.iters
    progress_bar.update(iters_skipped)
    loader_window.increment_progress(increment_value=iters_skipped)
    end = time()
    elapsed = end - start

    msg = (f"Simulation complete. Sim time: {UtilFuncs.get_time_str(fire.curr_time_s)}, "
        f"took {UtilFuncs.get_time_str(elapsed, True)} seconds to compute.")

    if fire.logger:
        fire.logger.log_message(msg)

    loader_window.set_text(f"Saving log file for simulation ({i+1}/{num_runs})")
    
    if fire.logger:
        fire.logger.finish(fire)

def handle_interrupt(logger, fire):
    """Function to handle user interrupts while a sim is running.
    """
    if logger is not None:
        print("\nUser interrupt detected. Finalizing logging...")
        logger.finish(fire, True)
    else:
        sys.exit(0)

def sim_loop(sim_params: SimParams):
    """Main function that gets user input from GUI and runs the specified simulation(s)
    """
    num_runs = sim_params.num_runs 
    duration = sim_params.duration_s
    time_step = sim_params.t_step_s

    # Get user code info
    user_code_path = sim_params.user_path
    user_code_class = sim_params.user_class

    # Create loader window object
    loader_window = LoaderWindow('Fire sim', max_value=num_runs*(duration/time_step)+1)
    loader_window.set_text("Initializing simulations...")

    fire, viz_on, viz = initialize(sim_params)

    if sim_params.write_logs:
        logger = Logger(sim_params.log_folder)

        logger.save_initial_state(fire)
        logger.log_metadata(sim_params, fire)
        
    else:
        logger = None


    print("Running simulations... ")
    print("")

    # Create command line progress bar
    progress_bar = tqdm(total=(num_runs*(fire.sim_duration/fire.time_step)),
                        desc='Total progress', position=1, leave=True)

    curr_fire = None

    for i in range(num_runs):
        if num_runs > 1:
            try:
                fire.progress_bar = None
                fire._visualizer = None
                curr_fire = copy.deepcopy(fire)
            except Exception as e:
                import traceback
                traceback.print_exc()
        else:
            curr_fire = fire

        curr_fire.set_visualizer(viz)

        if viz_on:
            viz.set_sim(curr_fire)

        # Register the signal handler
        signal.signal(signal.SIGINT, lambda signum, frame: handle_interrupt(logger, curr_fire))

        curr_fire.logger = logger
        loader_window.set_text(f"Running simulation ({i+1}/{num_runs})")
        run_sim(curr_fire, viz, progress_bar, loader_window, viz_on, user_code_path,
                user_code_class, i, num_runs)

        if viz_on:
            viz.reset_figure(done = i==num_runs-1)

    progress_bar.close()
    loader_window.set_text(f"Finished running {num_runs} simulations(s)")
    loader_window.close()

    print("")
    print(f"Finished running {num_runs} simulation(s)")

def load_sim_params(cfg_path: str) -> SimParams:
    """Load simulation parameters from .cfg file"""
    config = configparser.ConfigParser()
    config.read(cfg_path)

    # Parse Map Data
    map_params = None
    if "Map" in config:
        folder = config["Map"]["folder"]
        pkl_path = os.path.join(folder, "map_params.pkl")

        print(f"pkl_path: {pkl_path}")

        if os.path.exists(pkl_path):
            with open(pkl_path, "rb") as f:
                map_params = pickle.load(f)
        else:
            raise FileNotFoundError(f"Error in {cfg_path}: MapParams file not found in '{folder}'. Ensure 'map_params.pkl' exists.")
    else:
        raise ValueError(f"Error in {cfg_path}: Missing 'Map' section in the .cfg file.")

    # Parse weather data
    weather_input_type = config["Weather"].get("input_type", None)

    if weather_input_type is None:
        raise ValueError(f"Error in {cfg_path}: 'input_type' must be specified in the [Weather] section.")

    mesh_resolution = config["Weather"].getint("mesh_resolution", None)

    if mesh_resolution is None:
        mesh_resolution = 250
        print(f"Warning: Mesh resolution for WindNinja not specified in {cfg_path}, defaulting to 250m.")

    start_iso_datetime = config["Weather"].get("start_datetime", None)

    if start_iso_datetime is None:
        raise ValueError(f"Error in {cfg_path}:'start_datetime' must be specified in the [Weather] section.")

    start_datetime = datetime.fromisoformat(start_iso_datetime)

    weather_file = config["Weather"].get("file", None)

    if weather_input_type == "File":
        if weather_file is None:
            raise ValueError(f"Error in {cfg_path}: 'file' must be specified in the [Weather] section when using 'File' input type.")
        
        end_iso_datetime = config["Weather"].get("end_datetime", None)
        end_datetime = datetime.fromisoformat(end_iso_datetime)
        duration_s = (end_datetime - start_datetime).total_seconds()

        if duration_s <= 0:
            raise ValueError(f"End datetime must come after start datetime")

    elif weather_input_type == "OpenMeteo":
        end_iso_datetime = config["Weather"].get("end_datetime", None)
        if end_iso_datetime is None:
            duration_s = config["Simulation"].getint("duration_s", None)
            if duration_s is None:
                raise ValueError(f"Error in {cfg_path}: When using OpenMeteo 'duration_s' must be specified in the [Simulation] section if no End datetime is provided.")
            else:
                end_datetime = start_datetime + timedelta(seconds=duration_s)
        else:
            end_datetime = datetime.fromisoformat(end_iso_datetime)
            duration_s = (end_datetime - start_datetime).total_seconds()

    if start_datetime >= end_datetime:
        raise ValueError(f"Error in {cfg_path}: Start datetime must be before end datetime.")

    weather_params = WeatherParams(
        input_type=weather_input_type,
        file=config["Weather"].get("file", None),
        mesh_resolution=mesh_resolution,
        start_datetime=start_datetime,
        end_datetime=end_datetime
    )

    init_mf_list_str = config["Weather"].get("init_mf", "0.06, 0.07, 0.08")
    init_mf_list = [float(val.strip()) for val in init_mf_list_str.split(",")]

    write_logs = config["Simulation"].getboolean("write_logs", None)
    log_folder = config["Simulation"].get("log_folder", None)

    if write_logs is None:
        if log_folder is None:
            write_logs = False
        else:
            write_logs = True
    elif write_logs and log_folder is None:
        raise ValueError(f"Error in {cfg_path}: 'log_folder' must be specified if 'write_logs' is set to True.")

    t_step_s = config["Simulation"].getint("t_step_s", None)
    if t_step_s is None:
        raise ValueError(f"Error in {cfg_path}: 't_step_s' (time step) must be specified in the [Simulation] section.")

    cell_size = config["Simulation"].getint("cell_size_m", None)
    if cell_size is None:
        raise ValueError(f"Error in {cfg_path}: 'cell_size' must be specified in the [Simulation] section.")

    model_spotting = config["Simulation"].getboolean("model_spotting", False)
    canopy_species = config["Simulation"].getint("canopy_species", 5)
    dbh_cm = config["Simulation"].getfloat("dbh_cm", 20)
    spot_ign_prob = config["Simulation"].getfloat("spot_ign_prob", 0.05)
    min_spot_dist_m = config["Simulation"].getfloat("min_spot_dist_m", 50)
    spot_delay_s = config["Simulation"].getint("spot_delay_s", 30)

    user_class = str(config["Simulation"].get("user_class", ""))
    user_path = str(config["Simulation"].get("user_path", ""))

    if user_class is None or user_path is None:
        user_class = ""
        user_path = ""

    sim_params = SimParams(
        map_params=map_params,
        log_folder=log_folder,
        weather_input=weather_params,
        t_step_s=t_step_s,
        cell_size=cell_size,
        init_mf=init_mf_list,
        model_spotting=model_spotting,
        canopy_species=canopy_species,
        dbh_cm=dbh_cm,
        spot_ign_prob=spot_ign_prob,
        min_spot_dist=min_spot_dist_m,
        spot_delay_s=spot_delay_s,
        duration_s=duration_s,
        visualize=config["Simulation"].getboolean("visualize", False),
        num_runs=config["Simulation"].getint("num_runs", 1),
        user_path=user_path,
        user_class=user_class,
        write_logs=write_logs
    )

    return sim_params

def main():

    parser = argparse.ArgumentParser(description="Run fire simulation")
    parser.add_argument("--config", type=str, help="Path to .cfg file")
    parser.add_argument("--profile", action="store_true", help="Enable profiling of the simulation")

    args = parser.parse_args()

    if args.config:
        print(f"Loading simulation params from {args.config}...")
        sim_params = load_sim_params(args.config)

        sim_loop(sim_params)

    else:
        print("Starting sim initialization GUI...")
        folder_selector = SimFolderSelector(sim_loop)
        folder_selector.run()

import cProfile
import pstats
import sys

def profiled_main():
    profiler = cProfile.Profile()
    profiler.enable()

    
    main()

    profiler.disable()
    stats = pstats.Stats(profiler).strip_dirs().sort_stats('cumulative')
    stats.print_stats(20)  # Show top 20 time-consuming functions

    # Save profile to file for snakeviz
    profiler.dump_stats('fire_sim_profile.prof')
    print("\nProfile saved as 'fire_sim_profile.prof'. To visualize, run:")
    print("    snakeviz fire_sim_profile.prof")

if __name__ == "__main__":
    if "--profile" in sys.argv:
        profiled_main()
    else:
        main()

