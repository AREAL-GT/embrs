"""Module containing code that loads parameters from user input and runs the simulations
"""
from time import time
import signal
import importlib
import sys
import pickle
import json
import copy
import os
from typing import Tuple
from tqdm import tqdm
import numpy as np
from shapely.geometry import shape, LineString
from embrs.fire_simulator.visualizer import Visualizer
from embrs.fire_simulator.logger import Logger
from embrs.fire_simulator.fire import FireSim
from embrs.utilities.file_io import SimFolderSelector, LoaderWindow
from embrs.utilities.fire_util import UtilFuncs
from embrs.utilities.sim_input import SimInput, DataMap, WindDataMap
from embrs.utilities.wind_forecast import gen_forecast
from embrs.base_classes.control_base import ControlClass


def initialize(params: dict) -> Tuple[FireSim, bool, Visualizer]:
    """Initializes a fireSim object and a Visualizer(if selected) based on user inputs

    :param params: dictionary containing all user's inputs and preferenes, generated by
                   SimFolderSelector class.
    :type params: dict
    :return: tuple containing a FireSim object, a bool variable specifying if real-time 
             visualization was selected, and a Visualizer object. If real-time visualization not
             selected Visualizer will be None.
    :rtype: Tuple[FireSim, bool, Visualizer]
    """

    sim_input = construct_sim_input(params)

    # Initialize the simulator
    fire = FireSim(sim_input)

    # Initialize the visualizer, if visualization is selected
    if sim_input.viz_on:
        viz = Visualizer(fire)
    else:
        viz = None

    return fire, sim_input.viz_on, viz

def run_sim(fire: FireSim, viz: Visualizer, progress_bar: tqdm, loader_window: LoaderWindow,
            viz_on: bool, user_code_path: str, user_code_class: str, i:int, num_runs:int):
    """Function that runs the fire simulation and user code. Runs until the sim duration is reached
    or the fire is extinguished.

    :param fire: FireSim object to be run
    :type fire: FireSim
    :param viz: Visualizer object used for real-time visualization
    :type viz: Visualizer
    :param progress_bar: tqdm progress bar for command line display
    :type progress_bar: tqdm
    :param loader_window: LoaderWindow object used for generating a tk window that displays 
                          progress
    :type loader_window: LoaderWindow
    :param viz_on: boolean variable specifying whether the sim should be displayed in real-time
                   or not
    :type viz_on: bool
    :param user_code_path: Path to the user's selected module to run in parallel with sim
    :type user_code_path: str
    :param user_code_class: Name of the user's selected class to run in parallel with sim
    :type user_code_class: str
    :param i: Current number of simulation running
    :type i: int
    :param num_runs: Number of total simulations to be run
    :type num_runs: int
    """
    start = time()

    time_since_last_update = 20
    last_update = 0

    if user_code_path == "":
        user = None
    else:
        # Strip the extension and path
        user_module_name = os.path.splitext(os.path.basename(user_code_path))[0]

        # Dynamically import the module
        user_module = importlib.import_module(user_module_name)

        # Access the class within the module
        UserCodeClass = getattr(user_module, user_code_class)

        # Check if the user's class is a subclass of the abstract base class
        if not issubclass(UserCodeClass, ControlClass):
            raise TypeError(f"{user_code_class} is not a subclass of ControlClass")

        user = UserCodeClass(fire)  # Construct the user object

    if fire.logger:
        fire.logger.start_status_log()

    while not fire.finished:

        fire.iterate()

        if user:
            user.process_state(fire)

        progress_bar.update()
        loader_window.increment_progress()

        # ----------- Perform real-time plotting ------------- #
        if viz_on:
            time_since_last_update = fire.curr_time_s - last_update

            if time_since_last_update >= fire.display_frequency:
                viz.update_grid(fire)
                last_update = fire.curr_time_s

    iters_skipped = ((fire.sim_duration/fire.time_step) + 1) - fire.iters
    progress_bar.update(iters_skipped)
    loader_window.increment_progress(increment_value=iters_skipped)
    end = time()
    elapsed = end - start

    msg = (f"Simulation complete. Sim time: {UtilFuncs.get_time_str(fire.curr_time_s)}, "
        f"took {UtilFuncs.get_time_str(elapsed, True)} seconds to compute.")

    if fire.logger:
        fire.logger.log_message(msg)

    loader_window.set_text(f"Saving log file for simulation ({i+1}/{num_runs})")
    
    if fire.logger:
        fire.logger.finish(fire)

def handle_interrupt(logger, fire):
    """Function to handle user interrupts while a sim is running.
    """
    if logger is not None:
        print("\nUser interrupt detected. Finalizing logging...")
        logger.finish(fire, True)
    else:
        sys.exit(0)

def sim_loop(params: dict):
    """Main function that gets user input from GUI and runs the specified simulation(s)
    """

    # params = {'input': '/Users/rjdp3/Documents/embrs_release/src/rothermel_sample_map', 'log': '/Users/rjdp3/Documents/Research/rothermel_logs', 'wind': '/Users/rjdp3/Documents/embrs_release/src/sample_wind_forecasts/north_const.json', 't_step': 5, 'cell_size': 10, 'sim_time': 86400.0, 'viz_on': True, 'num_runs': 1, 'user_path': '', 'class_name': '', 'zero_wind': False}


    num_runs = params['num_runs']
    duration = params['sim_time']
    time_step = params['t_step']

    # Get user code info
    user_code_path = params['user_path']
    user_code_class = params['class_name']

    # Create loader window object
    loader_window = LoaderWindow('Fire sim', max_value=num_runs*(duration/time_step)+1)
    loader_window.set_text("Initializing simulations...")

    fire, viz_on, viz = initialize(params)

    if params['write_log_files']:
        data_logger = Logger(params['log'])
        data_logger.store_metadata(params, fire)
        data_logger.store_init_fire_obj(fire)

    else:
        data_logger = None


    print("Running simulations... ")
    print("")

    # Create command line progress bar
    progress_bar = tqdm(total=(num_runs*(fire.sim_duration/fire.time_step)),
                        desc='Total progress', position=1, leave=True)

    curr_fire = None

    for i in range(num_runs):
        if num_runs > 1:
            curr_fire = copy.deepcopy(fire)

        else:
            curr_fire = fire

        # Register the signal handler
        signal.signal(signal.SIGINT, lambda signum, frame: handle_interrupt(data_logger, curr_fire))

        curr_fire.logger = data_logger
        loader_window.set_text(f"Running simulation ({i+1}/{num_runs})")
        run_sim(curr_fire, viz, progress_bar, loader_window, viz_on, user_code_path,
                user_code_class, i, num_runs)

        if viz_on:
            viz.reset_figure(done = i==num_runs-1)

    progress_bar.close()
    loader_window.set_text(f"Finished running {num_runs} simulations(s)")
    loader_window.close()

    print("")
    print(f"Finished running {num_runs} simulation(s)")

def construct_sim_input(params:dict) -> SimInput:
    # TODO: does this function belong in main.py?

    # Construct SimInput object
    sim_input = SimInput()

    # Folder Setup
    input_folder = params['input']
    input_foldername = os.path.basename(input_folder)

    # Real-time viz
    viz_on = params['viz_on']
    sim_input.viz_on = viz_on

    # Map Setup
    cell_size = params['cell_size'] # meters
    time_step = params['t_step'] # seconds
    sim_duration = params['sim_time']

    sim_input.cell_size = cell_size
    sim_input.time_step = time_step
    sim_input.duration_s = sim_duration 

    # Read JSON map file
    with open(input_folder + '/' + input_foldername + '.json', 'r') as f:
        data = json.load(f)

    # Create elevation DataMap object
    topography_map = np.load(data['topography']['file'])
    topography_resolution = data['topography']['resolution']

    elevation = DataMap(topography_map, topography_resolution)
    sim_input.elevation = elevation

    # Create fuel DataMap object
    fuel_map = np.load(data['fuel']['file'])
    fuel_resolution = data['fuel']['resolution']

    fuel = DataMap(fuel_map, fuel_resolution)
    sim_input.fuel = fuel

    # Create aspect DataMap object
    aspect_map = np.load(data['aspect']['file'])
    aspect_resolution = data['aspect']['resolution']
    
    aspect = DataMap(aspect_map, aspect_resolution)
    sim_input.aspect = aspect

    # Create slope DataMap object
    slope_map = np.load(data['slope']['file'])
    slope_resolution = data['slope']['resolution']
    
    slope = DataMap(slope_map, slope_resolution)
    sim_input.slope = slope

    sim_input.north_angle = data['north_angle_deg']
    
    ignition_dicts = data['initial_ignition']
    initial_ignition = [shape(d) for d in ignition_dicts]
    
    sim_input.initial_ignition = initial_ignition
    
    fire_breaks = [{'geometry': LineString(fb['geometry']['coordinates']),
                    'fuel_value': fb['fuel_value']} for fb in data['fire_breaks']]

    sim_input.fire_breaks = fire_breaks

    if 'roads' in data:
        with open(data['roads']['file'], 'rb') as f:
            roads = pickle.load(f)
    else:
        roads = None

    sim_input.roads = roads

        # Save resolution, width, and height into variables
    width_m = data['topography']['width_m']
    height_m = data['topography']['height_m']

    sim_size = (width_m, height_m)
    sim_input.size = sim_size
    
    # Generate wind forecast
    # TODO: should mesh resolution be a user input?
    wind_resolution = 30
    forecast_seed_path = params['wind']
    forecast_seed_type = params['wind_type']
    elevation_path = data['topography']['tif_file_path']
    vegetation_path = "trees" #data['vegetation']['tif_file_path'] # TODO: Implement vegetation

    # TODO: make it an option to save wind forecast to a file somewhere
    if not params['zero_wind']:
        wind_forecast, wind_time_step = gen_forecast(elevation_path, vegetation_path, forecast_seed_path, forecast_seed_type, sim_input.north_angle, mesh_resolution=wind_resolution)

    else:
        wind_forecast = np.zeros((1, *topography_map.shape, 2))
        wind_time_step = 1e10

    wind = WindDataMap(wind_forecast, wind_resolution, wind_time_step)

    sim_input.wind = wind

    # Calculate simSize
    num_cols = int(np.floor(width_m/(np.sqrt(3)*cell_size)))
    num_rows = int(np.floor(height_m/(1.5*cell_size)))

    sim_shape = (num_rows, num_cols)


    sim_input.shape = sim_shape
    
    return sim_input


def main():

    # params = {'input': '/Users/rui/Documents/Research/Code/embrs_maps/fox_crop_test',
    #           'log': '/Users/rui/Documents/Research/Code/embrs_logs',
    #           'wind': '/Users/rui/Documents/Research/Code/embrs/sample_wind_forecasts/burnout_wind_forecast.json', 'wind_type': 'Domain Average Wind',
    #           't_step': 5, 'cell_size': 10, 'sim_time': 18000.0, 'viz_on': True, 'num_runs': 1, 'user_path': '', 'class_name': '', 'zero_wind': True, 'write_log_files': False}


    # sim_loop(params)

    folder_selector = SimFolderSelector(sim_loop)
    folder_selector.run()

if __name__ == "__main__":
    main()
