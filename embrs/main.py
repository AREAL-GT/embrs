"""Module containing code that loads parameters from user input and runs the simulations
"""
from time import time
import signal
import importlib
import sys
import copy
import os
from typing import Tuple
from tqdm import tqdm
from embrs.fire_simulator.visualizer import Visualizer
from embrs.fire_simulator.logger import Logger
from embrs.fire_simulator.fire import FireSim
from embrs.utilities.file_io import SimFolderSelector, LoaderWindow
from embrs.utilities.fire_util import UtilFuncs
from embrs.base_classes.control_base import ControlClass
from embrs.utilities.data_classes import SimParams

def initialize(sim_params: SimParams) -> Tuple[FireSim, bool, Visualizer]:
    """Initializes a fireSim object and a Visualizer(if selected) based on user inputs

    :param params: dictionary containing all user's inputs and preferenes, generated by
                   SimFolderSelector class.
    :type params: dict
    :return: tuple containing a FireSim object, a bool variable specifying if real-time 
             visualization was selected, and a Visualizer object. If real-time visualization not
             selected Visualizer will be None.
    :rtype: Tuple[FireSim, bool, Visualizer]
    """

    # Initialize the simulator
    fire = FireSim(sim_params)

    # Initialize the visualizer, if visualization is selected
    if sim_params.visualize:
        viz = Visualizer(fire)
    else:
        viz = None

    return fire, sim_params.visualize, viz

def run_sim(fire: FireSim, viz: Visualizer, progress_bar: tqdm, loader_window: LoaderWindow,
            viz_on: bool, user_code_path: str, user_code_class: str, i:int, num_runs:int):
    """Function that runs the fire simulation and user code. Runs until the sim duration is reached
    or the fire is extinguished.

    :param fire: FireSim object to be run
    :type fire: FireSim
    :param viz: Visualizer object used for real-time visualization
    :type viz: Visualizer
    :param progress_bar: tqdm progress bar for command line display
    :type progress_bar: tqdm
    :param loader_window: LoaderWindow object used for generating a tk window that displays 
                          progress
    :type loader_window: LoaderWindow
    :param viz_on: boolean variable specifying whether the sim should be displayed in real-time
                   or not
    :type viz_on: bool
    :param user_code_path: Path to the user's selected module to run in parallel with sim
    :type user_code_path: str
    :param user_code_class: Name of the user's selected class to run in parallel with sim
    :type user_code_class: str
    :param i: Current number of simulation running
    :type i: int
    :param num_runs: Number of total simulations to be run
    :type num_runs: int
    """
    start = time()

    time_since_last_update = 20
    last_update = 0

    if user_code_path == "":
        user = None
    else:
        # Strip the extension and path
        user_module_name = os.path.splitext(os.path.basename(user_code_path))[0]

        # Dynamically import the module
        user_module = importlib.import_module(user_module_name)

        # Access the class within the module
        UserCodeClass = getattr(user_module, user_code_class)

        # Check if the user's class is a subclass of the abstract base class
        if not issubclass(UserCodeClass, ControlClass):
            raise TypeError(f"{user_code_class} is not a subclass of ControlClass")

        user = UserCodeClass(fire)  # Construct the user object

    if fire.logger:
        fire.logger.start_status_log()

    while not fire.finished:

        fire.iterate()

        if user:
            user.process_state(fire)

        progress_bar.update()
        loader_window.increment_progress()

        # ----------- Perform real-time plotting ------------- #
        if viz_on:
            time_since_last_update = fire.curr_time_s - last_update

            if time_since_last_update >= fire.display_frequency:
                viz.update_grid(fire)
                last_update = fire.curr_time_s

    iters_skipped = ((fire.sim_duration/fire.time_step) + 1) - fire.iters
    progress_bar.update(iters_skipped)
    loader_window.increment_progress(increment_value=iters_skipped)
    end = time()
    elapsed = end - start

    msg = (f"Simulation complete. Sim time: {UtilFuncs.get_time_str(fire.curr_time_s)}, "
        f"took {UtilFuncs.get_time_str(elapsed, True)} seconds to compute.")

    if fire.logger:
        fire.logger.log_message(msg)

    loader_window.set_text(f"Saving log file for simulation ({i+1}/{num_runs})")
    
    if fire.logger:
        fire.logger.finish(fire)

def handle_interrupt(logger, fire):
    """Function to handle user interrupts while a sim is running.
    """
    if logger is not None:
        print("\nUser interrupt detected. Finalizing logging...")
        logger.finish(fire, True)
    else:
        sys.exit(0)

def sim_loop(sim_params: SimParams):
    """Main function that gets user input from GUI and runs the specified simulation(s)
    """
    num_runs = sim_params.num_runs 
    duration = sim_params.duration_s
    time_step = sim_params.t_step_s

    # Get user code info
    user_code_path = sim_params.user_path
    user_code_class = sim_params.user_class

    # Create loader window object
    loader_window = LoaderWindow('Fire sim', max_value=num_runs*(duration/time_step)+1)
    loader_window.set_text("Initializing simulations...")

    fire, viz_on, viz = initialize(sim_params)

    if sim_params.write_logs:
        data_logger = Logger(sim_params.log_folder)
        # TODO: need to rewrite these when we rewrite logger
        # data_logger.store_metadata(params, fire)
        # data_logger.store_init_fire_obj(fire)

    else:
        data_logger = None


    print("Running simulations... ")
    print("")

    # Create command line progress bar
    progress_bar = tqdm(total=(num_runs*(fire.sim_duration/fire.time_step)),
                        desc='Total progress', position=1, leave=True)

    curr_fire = None

    for i in range(num_runs):
        if num_runs > 1:
            curr_fire = copy.deepcopy(fire)

        else:
            curr_fire = fire

        # Register the signal handler
        signal.signal(signal.SIGINT, lambda signum, frame: handle_interrupt(data_logger, curr_fire))

        curr_fire.logger = data_logger
        loader_window.set_text(f"Running simulation ({i+1}/{num_runs})")
        run_sim(curr_fire, viz, progress_bar, loader_window, viz_on, user_code_path,
                user_code_class, i, num_runs)

        if viz_on:
            viz.reset_figure(done = i==num_runs-1)

    progress_bar.close()
    loader_window.set_text(f"Finished running {num_runs} simulations(s)")
    loader_window.close()

    print("")
    print(f"Finished running {num_runs} simulation(s)")

def main():
    folder_selector = SimFolderSelector(sim_loop)
    folder_selector.run()

if __name__ == "__main__":
    main()
